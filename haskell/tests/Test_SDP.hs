-- |
-- Module        : Test_SDP
-- Description   : This module contains property-based tests for the SDP model.
-- Tool          : QuickCheck
-- Key Components:
-- - Arbitrary   : To enable random generation of test cases.
-- - `dummyProb2`: Helper to create a probability distribution over a list of elements.

module Test_SDP where

import Data.Map (Map)
import qualified Data.Map as Map
import GHGCase
import SDPCompute
import Test.QuickCheck
import Prob (Prob, runProb, Probability, weights, unProb)

-- =====================================================================
-- Arbitrary Instances
-- =====================================================================

instance Arbitrary Action where
  arbitrary = elements sdpGetActions

instance Arbitrary State where 
  arbitrary = elements sdpStates


-- | Specific implementation to test. Exchange depending on model for testing. 
sdpInstance   = ghgcase
sdpGetActions = GHGCase.getActions
sdpNext       = GHGCase.next
sdpActions    = GHGCase.actions
sdpStates     = GHGCase.getStates

-- Works for now, could change later to be more formally:

{-
class SDPModel m where
  getActions :: m -> State -> [Action]
  next       :: m -> State -> Action -> State
  actions    :: m -> [Action]
  getStates  :: m -> [State]

  instance SDPModel GHGCase where
  getActions = GHGCase.getActions
  next       = GHGCase.next
  actions    = GHGCase.actions
  getStates  = GHGCase.getStates

-}

-- =====================================================================
-- Test val
-- =====================================================================

-- | Test that when the policy sequence is empty, the value function `val` returns 0.
prop_valEmptyPolicy :: State -> Property
prop_valEmptyPolicy x =
  forAll genValidInt $ \t -> 
    val sdpInstance t [] x == 0

-- | Test that the value function `val` always returns a non-negative value for any generated policy sequence.
prop_valNonNegative :: State -> Property
prop_valNonNegative x =
  forAll genValidIntZero $ \t ->
  forAll genValidInt $ \n ->
    let policySeq = bi sdpInstance t n
    in val ghgcase t policySeq x >= 0

-- | Test that a longer policy sequence is at least as good as the original sequence (geq).
prop_longerPolicyBetterOrEqual :: Int -> State -> Property
prop_longerPolicyBetterOrEqual t x =
  forAll genValidIntZero $ \t ->
  forAll genValidInt $ \n ->
    let ps = bi sdpInstance t n
    in not (null ps) ==>
      let v1 = val sdpInstance t ps x
          v2 = val sdpInstance t (ps ++ [last ps]) x
      in v2 >= v1

-- TODO, error checks? Import Control.Exception


-- =====================================================================
-- Test bi
-- =====================================================================

-- | Test that the length of the policy sequence generated by `bi` matches the specified horizon `n`.
prop_biLength :: Property
prop_biLength =
  forAll genValidInt $ \t -> 
  forAll genValidInt $ \n -> 
  length (bi sdpInstance t n) == n

-- | Test that `bi` returns an empty policy sequence when n <= 0, regardless of timestep (value of t).
prop_biEmptyPolicy :: Property
prop_biEmptyPolicy =
  forAll genValidIntZero $ \t ->
    bi sdpInstance t 0 == []

-- | Test that the sequence produced by `bi` has exactly n elements.
prop_biCorrectLength :: Int -> Property
prop_biCorrectLength t =
  forAll genValidIntZero $ \t ->
  forAll genValidInt $ \n ->
    length (bi sdpInstance t n) == n


-- | Test that every element of the sequence produced by `bi` is a valid policy.
prop_biCorrectElements :: Property
prop_biCorrectElements =
  forAll genValidIntZero $ \t ->
  forAll genValidInt $ \n ->
    all (\p -> all (`Map.member` p) sdpStates) (bi sdpInstance t n)

-- =====================================================================
-- Test bestExt, worstExt
-- =====================================================================

-- | Test that the length of the list returned by `bestExt` matches the number of states.
prop_bestExtWorstCorrectLength :: Property
prop_bestExtWorstCorrectLength =
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    let ps = bi sdpInstance t n
    in length (bestExt sdpInstance t ps)  == length sdpStates 
    && length (worstExt sdpInstance t ps) == length sdpStates

-- | Test that the policy from `bestExt` is "better" (higher val) than that of `worstExt`.
prop_bestExtGEQworst :: State -> Property
prop_bestExtGEQworst s =
  forAll genValidInt $ \n ->
  forAll genValidInt $ \t ->
    let ps       = bi ghgcase t n
        bestPol  = bestExt sdpInstance t ps
        worstPol = worstExt sdpInstance t ps
        bestVal  = val sdpInstance t (bestPol : ps) s
        worstVal = val sdpInstance t (worstPol : ps) s
    in bestVal  >= worstVal

-- | Test that applying `bestExt` twice produces the same result.
prop_optExtDeterministic :: Property
prop_optExtDeterministic =
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    let ps = bi sdpInstance t n
        p1 = bestExt sdpInstance t ps
        p2 = bestExt sdpInstance t ps
    in p1 == p2

-- | Test that applying `bestExt` twice produces the same value for the policy sequence.
prop_bestExtPolicyIdempotent :: State -> Property
prop_bestExtPolicyIdempotent s =
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    let ps = bi sdpInstance t n
        bestP = bestExt sdpInstance t ps
        newPs = bestP : ps
        v1 = val sdpInstance t newPs s
        v2 = val sdpInstance t newPs s
    in v1 == v2

{- prop_bestExtMaximizeValue :: State -> Property
prop_bestExtMaximizeValue s = 
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    let ps = bi sdpInstance t n -}
        
-- =====================================================================
-- Test best
-- =====================================================================

-- | Test that the action returned by `best` is one of the possible actions in that state at time t.
prop_bestActionIsValid :: State -> Property
prop_bestActionIsValid s =
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    let (a, _) = best sdpInstance t n s
    in a `elem` (sdpActions t s)

-- | Test that `best` returns the same value as computing `val` with the returned action and policy.
prop_bestValMatchesVal :: State -> Property
prop_bestValMatchesVal s =
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    let (a, v) = best sdpInstance t n s
        ps = bi sdpInstance (t + 1) (n - 1)
        p = Map.singleton s a
        v' = val sdpInstance t (p : ps) s
    in v === v'

-- | Test that the value returned by `best` is greater than or equal to any other possible single-action value.
prop_bestValIsOptimal :: State -> Property
prop_bestValIsOptimal s =
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    let (a, vBest) = best sdpInstance t n s
        ps = bi sdpInstance (t + 1) (n - 1)
        otherActions = sdpActions t s
        altVals = [val sdpInstance t (Map.singleton s a' : ps) s | a' <- otherActions]
    in all (<= vBest) altVals

-- =====================================================================
-- Test meas
-- =====================================================================

-- | Test that the value returned from `mMeas` is never larger than 1.0.
prop_valueLTOne :: State -> Property
prop_valueLTOne x =
  forAll genValidInt $ \t ->
  forAll genValidInt $ \n ->
    mMeas sdpInstance t n x <= 1.0

-- =====================================================================
-- Test next
-- =====================================================================

-- | Test that probabilities returned by `next` sum to 1.
prop_sumEqualToOne :: State -> Property
prop_sumEqualToOne x = 
  forAll genValidInt $ \t ->
  forAll (genValidAction t x) $ \s ->
    sum (Prob.weights (sdpNext t x s)) >= 0.99 &&
    sum (Prob.weights (sdpNext t x s)) <= 1.01

-- | Test that `next` is deterministic (returns the same probability distribution given the same inputs).
prop_nextDeterministic :: State -> Property
prop_nextDeterministic x = 
  forAll genValidInt $ \t ->
  forAll (genValidAction t x) $ \s ->
    let d0 = unzip $ unProb (sdpNext t x s)
        d1 = unzip $ unProb (sdpNext t x s)
    in fst d0 == fst d1 && snd d0 == snd d1

-- =====================================================================
-- Test Runners
-- =====================================================================

-- | Run tests for `val`.
testVal :: IO ()
testVal = do
  quickCheck prop_valEmptyPolicy
  quickCheck prop_valNonNegative
  quickCheck prop_longerPolicyBetterOrEqual

-- | Run tests for `bi`.
testBi :: IO ()
testBi = do
  quickCheck prop_biLength
  quickCheck prop_biEmptyPolicy
  quickCheck prop_biCorrectLength
  quickCheck prop_biCorrectElements

-- | Run tests for `bestExt` and `worstExt`.
testBestExt :: IO ()
testBestExt = do
  quickCheck prop_bestExtGEQworst
  quickCheck prop_bestExtWorstCorrectLength
  quickCheck prop_bestExtPolicyIdempotent
  quickCheck prop_optExtDeterministic

-- | Run tests for `best`.
testBest :: IO ()
testBest = do
  quickCheck prop_bestActionIsValid
  quickCheck prop_bestValMatchesVal
  quickCheck prop_bestValIsOptimal

-- | Run tests for `next`.
testNext :: IO ()
testNext = do
  quickCheck prop_sumEqualToOne
  quickCheck prop_nextDeterministic

-- | Run tests for `mMeas`.
testmMeas :: IO ()
testmMeas = do
  quickCheck prop_valueLTOne

-- | Run all tests.
testAll :: IO ()
testAll = do
  testVal
  testBi
  testBestExt
  testBest
  testNext
  testmMeas

-- =====================================================================
-- Utility Functions
-- =====================================================================

-- | Run `bi` with the given parameters.
runBi :: Int -> Int -> PolicySeq State Action
runBi t n = bi ghgcase t n

-- | Generate a valid integer in the range [1, 7].
genValidInt :: Gen Int
genValidInt = choose (1, 7)

-- | Generate a valid integer in the range [0, 7].
genValidIntZero :: Gen Int
genValidIntZero = choose (0, 7)

-- | Generate a valid action for a given state and time.
genValidAction :: Int -> State -> Gen Action
genValidAction t x = elements (GHGCase.actions t x)